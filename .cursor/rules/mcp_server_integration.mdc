---
description: "MCP (Model Context Protocol) server integration practices for the Living Truth Engine, ensuring proper tool usage and system integration"
globs: ["**/*.py", "**/mcp_servers/**/*", "**/.cursor/mcp.json"]
alwaysApply: true
---

# MCP Server Integration and Best Practices

## Description
This rule defines MCP (Model Context Protocol) server integration practices for the Living Truth Engine, ensuring proper tool usage and system integration.

## 🔧 **MCP Server Configuration**

### **MCP Hub Server Setup**
```json
// ✅ Good - Single MCP Hub Server configuration solving 63-tool limit issue
{
  "mcpServers": {
    "mcp_hub_server": {
      "command": "python3",
      "args": [
        "/home/mccoy/Projects/NotebookLM/LivingTruthEngine/src/mcp_servers/mcp_hub_server.py"
      ],
      "env": {
        "LANGFLOW_API_ENDPOINT": "http://localhost:7860",
        "LANGFLOW_API_KEY": "${LANGFLOW_API_KEY}",
        "LANGFLOW_PROJECT_ID": "399a0977-d08a-4d61-ba52-fd9811676762",
        "LM_STUDIO_ENDPOINT": "http://localhost:1234",
        "PYTHONPATH": "/home/mccoy/Projects/NotebookLM/LivingTruthEngine/src"
      },
      "description": "MCP Hub Server - Consolidated tool gateway providing access to all 63 tools via 15 meta-tools, avoiding Cursor's 40-tool limit"
    }
  }
}
```

### **MCP Hub Server Architecture**
- **✅ Single Gateway**: One MCP server exposing 15 meta-tools to Cursor
- **✅ Underlying Tools**: 63 tools across 8 servers accessible via hub routing
- **✅ Registry Management**: `config/tool_registry.json` with complete tool definitions
- **✅ Dynamic Loading**: Tools loaded on-demand using `importlib`
- **✅ Proxy Execution**: Hub routes calls to appropriate underlying servers
- **✅ Tool Categories**: Tools organized by function (analysis, system, langflow, etc.)

### **MCP Hub Server Tool Usage**
```python
# ✅ Good - Use MCP Hub Server meta-tools (15 total)
mcp_mcp_hub_server_list_tools()
mcp_mcp_hub_server_get_tool_details("query_langflow")
mcp_mcp_hub_server_execute_tool("query_langflow", {"query": "test"})
mcp_mcp_hub_server_search_tools("analysis")
mcp_mcp_hub_server_batch_execute_tools([{"tool": "get_status", "params": {}}])

# ✅ Good - Category-specific execution
mcp_mcp_hub_server_execute_analysis_tool("analyze_transcript", {"transcript_name": "test"})
mcp_mcp_hub_server_execute_langflow_tool("query_langflow", {"query": "test"})
mcp_mcp_hub_server_execute_system_tool("get_status", {})

# ❌ Bad - Direct tool calls (not available through hub)
mcp_living_truth_fastmcp_server_query_langflow()  # Use hub instead
mcp_langflow_mcp_server_query_langflow()         # Use hub instead
```

## 📋 **MCP Integration Checklist**

### **Before Using MCP Hub Server**
- [ ] **Verify MCP Hub Server is running** and accessible
- [ ] **Check tool availability** with `list_tools()` call
- [ ] **Validate input parameters** before calling tools
- [ ] **Handle errors gracefully** with proper fallbacks
- [ ] **Use appropriate meta-tool** for the task
- [ ] **Use batch operations** for efficiency when available
- [ ] **Use category-specific tools** for better organization
- [ ] **Check tool details** with `get_tool_details()` before execution

### **MCP Hub Server Operations**
- [ ] **Start MCP Hub Server** before development work (`python3 src/mcp_servers/mcp_hub_server.py`)
- [ ] **Monitor hub server health** during operations
- [ ] **Restart hub server** if tools become unresponsive
- [ ] **Update tool registry** when adding new tools (`config/tool_registry.json`)
- [ ] **Test meta-tool functionality** after changes
- [ ] **Reload registry** if needed (`reload_registry()`)

### **MCP Hub Server Best Practices**
- [ ] **Use MCP Hub Server meta-tools** for all operations
- [ ] **Use batch operations** for efficiency (e.g., `batch_execute_tools`)
- [ ] **Use category-specific tools** for better organization
- [ ] **Search tools first** with `search_tools()` to find appropriate tools
- [ ] **Get tool details** with `get_tool_details()` before execution
- [ ] **Document tool usage** in code and documentation
- [ ] **Handle tool errors** with appropriate messaging
- [ ] **Validate tool outputs** before using results
- [ ] **Use registry management** for tool discovery and organization

## 🔧 **MCP Hub Server Meta-Tools (15 total)**

### **Tool Discovery and Management**
```python
# ✅ Tool discovery and information
mcp_mcp_hub_server_list_tools()                    # List all available tools
mcp_mcp_hub_server_get_tool_details("tool_name")   # Get tool details and schema
mcp_mcp_hub_server_search_tools("query")           # Search tools by description
mcp_mcp_hub_server_get_tool_categories()           # Get tool categories
```

### **Tool Execution**
```python
# ✅ General tool execution
mcp_mcp_hub_server_execute_tool("tool_name", params)  # Execute any tool by name
mcp_mcp_hub_server_batch_execute_tools(tools_list)    # Execute multiple tools

# ✅ Category-specific execution
mcp_mcp_hub_server_execute_analysis_tool("analyze_transcript", {"transcript_name": "test"})
mcp_mcp_hub_server_execute_system_tool("get_status", {})
mcp_mcp_hub_server_execute_langflow_tool("query_langflow", {"query": "test"})
mcp_mcp_hub_server_execute_category_tools("analysis", tools_list)

# ✅ Proxy execution examples
result = mcp_mcp_hub_server_execute_tool(tool_name="query_langflow", params={"query": "Analyze patterns"})
result = mcp_mcp_hub_server_execute_tool(tool_name="analyze_transcript", params={"transcript_name": "test", "anonymize": True})

#### **Performance Monitoring**
```python
import time
start = time.time()
result = mcp_mcp_hub_server_execute_tool("query_langflow", {"query": "test"})
duration = time.time() - start
if duration > 1:
    print("Warning: Slow tool execution")
```

### **Tool Management**
```python
# ✅ Build new tool
mcp_mcp_hub_server_build_tool({
    "name": "new_tool",
    "description": "Test tool",
    "server": "living_truth_fastmcp_server",
    "module": "src.mcp_servers.living_truth_fastmcp_server",
    "function": "new_function",
    "params_schema": {"param1": {"type": "string"}}
})

# ✅ Update existing tool
mcp_mcp_hub_server_update_tool("existing_tool", {"description": "Updated description"})

# ✅ Delete tool
mcp_mcp_hub_server_delete_tool("old_tool")
```

### **Hub Server Management**
```python
# ✅ Hub server operations
mcp_mcp_hub_server_get_status()                    # Get hub server health
mcp_mcp_hub_server_reload_registry()               # Reload tool registry
```

## 🎯 **MCP Hub Server Standards**

### **Required Patterns**
- **Use MCP Hub Server** as the single gateway for all tool access
- **Update tool registry** - add new tools to `config/tool_registry.json`
- **Follow FastMCP patterns** - for underlying server implementations
- **Use proper naming conventions** - snake_case for methods, descriptive names
- **Organize by categories** - group tools by function (analysis, system, langflow, etc.)

### **Tool Registry Schema**
```json
{
  "name": "tool_name",
  "description": "Tool description",
  "server": "server_name",
  "module": "module.path",
  "function": "function_name",
  "params_schema": {
    "param_name": {"type": "string", "required": true},
    "optional_param": {"type": "integer", "default": 1000}
  }
}
```

**Registry Validation Example**:
```python
def validate_registry(registry: Dict) -> bool:
    """Validate tool registry structure and content."""
    required_keys = ['name', 'description', 'server']
    for tool in registry.get('tools', []):
        if not all(key in tool for key in required_keys):
            raise ValueError(f"Missing required keys in tool entry: {tool.get('name', 'unknown')}")
        
        # Validate params_schema if present
        if 'params_schema' in tool:
            for param_name, param_def in tool['params_schema'].items():
                if 'type' not in param_def:
                    raise ValueError(f"Parameter {param_name} missing type definition")
    
    return True

# Usage
try:
    with open('config/tool_registry.json', 'r') as f:
        registry = json.load(f)
    validate_registry(registry)
    print("✅ Registry validation passed")
except Exception as e:
    print(f"❌ Registry validation failed: {e}")

**Registry Backup**: Copy to `.bak` on load for corruption recovery.

### **Tool Management**
```python
# Build new tool
mcp_mcp_hub_server_build_tool({
    "name": "new_tool", 
    "description": "Test tool", 
    "server": "living_truth_fastmcp_server", 
    "module": "src.mcp_servers.living_truth_fastmcp_server", 
    "function": "new_function",
    "params_schema": {"param1": {"type": "string", "required": True}}
})

# Update existing tool
mcp_mcp_hub_server_update_tool("existing_tool", {"description": "Updated description"})

# Delete tool
mcp_mcp_hub_server_delete_tool("old_tool")
```

### **Performance Monitoring**
```python
import time

def measure_tool_performance(tool_name: str, params: Dict) -> Tuple[Any, float]:
    start = time.time()
    result = mcp_mcp_hub_server_execute_tool(tool_name, params)
    duration = time.time() - start
    if duration > 1:
        logger.warning(f"Slow execution: {duration}s for {tool_name}")
    if duration > 2:
        logger.error(f"Alert: Execution exceeded 2s for {tool_name}")
        # Optional: send_alert("slow_execution", tool_name, duration)
    return result, duration
```

### **Tool Registry Schema**
- **Valid Types**: 'string', 'int', 'float', 'bool', 'list', 'dict', 'any'—enforced in validation
- **Registry Size**: Maximum 200 tools with automatic warnings
- **Recovery Testing**: Test backup and recovery functionality

### **Integration Patterns**

#### **Adding New Tools to Hub Server**
```python
# ✅ Good - Add tool to underlying server
class LivingTruthEngine:
    def new_functionality(self, param: str) -> str:
        """Add new functionality to existing class."""
        # Implementation
        return result

# ✅ Good - Add tool to registry (config/tool_registry.json)
{
  "name": "new_functionality",
  "description": "New functionality for analysis",
  "server": "living_truth_fastmcp_server",
  "module": "src.mcp_servers.living_truth_fastmcp_server",
  "function": "new_functionality",
  "params_schema": {
    "param": {"type": "string", "required": true}
  }
}

# ✅ Good - Access via hub server
mcp_mcp_hub_server_execute_tool("new_functionality", {"param": "value"})
```

#### **LM Studio Integration Pattern**
```python
# ✅ Good - LM Studio method in LivingTruthEngine class
def get_lm_studio_models(self) -> str:
    """Get list of available models in LM Studio."""
    try:
        response = requests.get(f"{self.lm_studio_endpoint}/v1/models")
        if response.status_code == 200:
            models = response.json()
            return f"✅ Available models in LM Studio:\n{json.dumps(models, indent=2)}"
        else:
            return f"❌ Failed to get models: {response.status_code}"
    except Exception as e:
        return f"❌ Error accessing LM Studio: {e}"

# ✅ Good - Corresponding MCP tool
@mcp.tool()
def get_lm_studio_models() -> str:
    """Get list of available models in LM Studio."""
    return engine.get_lm_studio_models()
```

## 🚨 **Common MCP Issues**

### **JSON Syntax Errors**
- ❌ **Trailing commas** - Causes all MCP servers to disappear
- ❌ **Missing quotes** - Invalid JSON syntax
- ❌ **Wrong brackets** - Malformed JSON structure

### **Pattern Violations**
- ❌ **Using standard MCP** instead of FastMCP
- ❌ **Creating separate servers** when integration is possible
- ❌ **Not following existing structure** - inconsistent patterns

### **Configuration Issues**
- ❌ **Wrong file paths** - MCP servers can't find files
- ❌ **Missing environment variables** - Servers can't connect
- ❌ **Incorrect endpoints** - Wrong service ports

## 🔧 **MCP Troubleshooting**

### **Diagnosing MCP Hub Server Issues**
```bash
# Validate JSON syntax
python3 -m json.tool .cursor/mcp.json
python3 -m json.tool config/tool_registry.json

# Check MCP Hub Server status in Cursor
# Look for green dots (working) vs red dots (errors)

# Test MCP Hub Server manually
python3 src/mcp_servers/mcp_hub_server.py

# Check tool registry
python3 -c "import json; data=json.load(open('config/tool_registry.json')); print(f'Total tools: {data[\"total_tools\"]}')"
```

### **Hub-Specific Issues**
- **Hub Registry Load Failure**: Check config/tool_registry.json permissions; run `reload_registry()`
- **Proxy Errors**: Ensure underlying servers running; test with `get_status()`
- **Tool Not Found**: Verify tool exists in registry; check `list_tools()` output
- **Import Errors**: Verify module path in registry; check PYTHONPATH

### **Common Fixes**

#### **JSON Syntax Fix**
```json
# ❌ Bad - Trailing comma
{
  "mcpServers": {
    "server1": { ... },
    "server2": { ... },  // <- This comma causes issues
  }
}

# ✅ Good - No trailing comma
{
  "mcpServers": {
    "server1": { ... },
    "server2": { ... }   // <- No trailing comma
  }
}
```

#### **Integration Fix**
```python
# ❌ Bad - Separate MCP server
class NewMCPServer:
    def __init__(self):
        self.server = Server("new_server")

# ✅ Good - Integrate into existing
class LivingTruthEngine:
    def new_functionality(self) -> str:
        # Add to existing class
        pass

@mcp.tool()
def new_functionality() -> str:
    return engine.new_functionality()
```

## 📋 **MCP Development Checklist**

### **Before Adding New Tools**
- [ ] **Check existing tools** in registry for similar functionality
- [ ] **Add to underlying server** using FastMCP pattern
- [ ] **Update tool registry** in `config/tool_registry.json`
- [ ] **Follow naming conventions** consistently
- [ ] **Organize by category** (analysis, system, langflow, etc.)
- [ ] **Test via hub server** using `execute_tool()` or category-specific methods

### **When Adding New Tools**
- [ ] **Add method to underlying server** first
- [ ] **Add tool to registry** in `config/tool_registry.json`
- [ ] **Update total_tools count** in registry
- [ ] **Test tool via hub server** using `execute_tool()`
- [ ] **Verify tool appears** in `list_tools()` output

### **Before Updating Configuration**
- [ ] **Validate JSON syntax** with python3 -m json.tool
- [ ] **Check file paths** are correct
- [ ] **Verify environment variables** are set
- [ ] **Test hub server startup** manually
- [ ] **Validate tool registry** structure and completeness

## 🎯 **Current MCP Hub Server Architecture**

### **MCP Hub Server** (15 meta-tools)
- **File**: `src/mcp_servers/mcp_hub_server.py`
- **Pattern**: FastMCP with proxy/gateway architecture
- **Registry**: `config/tool_registry.json` with 63 tools across 8 servers
- **Meta-Tools**: list_tools, get_tool_details, execute_tool, search_tools, batch_execute_tools
- **Category Tools**: execute_analysis_tool, execute_system_tool, execute_langflow_tool
- **Management Tools**: get_status, reload_registry, get_tool_categories, execute_category_tools

### **Underlying Servers** (63 tools total)
1. **Living Truth FastMCP Server** (22 tools): LM Studio, Core, Batch, Utility, Automation
2. **Langflow MCP Server** (12 tools): JSON import/export, workflow management
3. **GitHub MCP Server** (4 tools): Repository management
4. **PostgreSQL MCP Server** (6 tools): Database operations
5. **Hugging Face MCP Server** (5 tools): Model access
6. **DevDocs MCP Server** (4 tools): Document retrieval
7. **Rulego MCP Server** (5 tools): Workflow orchestration
8. **MCP Solver Server** (5 tools): Constraint solving

### **Benefits**
- **Cursor Compliance**: Only 15 tools exposed, well under 40-tool limit
- **Full Access**: All 63 tools accessible via hub routing
- **Scalability**: Unlimited tool development behind scenes
- **Organization**: Tools categorized by function
- **Performance**: Optimal Cursor performance with reduced tool exposure

## 📊 **MCP Hub Server Metrics**
- ✅ **100% Cursor compliance** - Only 15 meta-tools exposed (under 40-tool limit)
- ✅ **100% tool access** - All 63 underlying tools accessible via hub
- ✅ **100% registry management** - Complete tool registry with definitions
- ✅ **100% category organization** - Tools organized by function
- ✅ **100% dynamic loading** - Tools loaded on-demand for efficiency
- ✅ **100% error handling** - All tools include proper error handling

## 🚀 **Best Practices Summary**

### **1. Always Check Existing**
- Look for existing MCP servers first
- Integrate into existing structure when possible
- Follow established patterns and naming

### **2. Use FastMCP Library**
- All MCP servers must use FastMCP
- Add methods to existing classes
- Create corresponding @mcp.tool() decorators

### **3. Validate Configuration**
- Always validate JSON syntax
- Check file paths and environment variables
- Test server startup manually

### **4. Follow Integration Patterns**
- Add functionality to existing classes
- Create corresponding MCP tools
- Update tool lists and documentation
mcp_living_truth_fastmcp_server_test_tool("message")
mcp_langflow_mcp_server_test_tool("message")
```

### **Langflow Integration Tools**
```python
# ✅ Query Langflow workflow
mcp_living_truth_fastmcp_server_query_langflow(
    query="Analyze this transcript for corroborating evidence",
    output_type="summary",
    anonymize=False
)
```

### **Langflow Integration Tools**
```python
# ✅ Query Langflow workflow
mcp_langflow_mcp_server_query_langflow(
    query="Analyze this transcript for Biblical patterns",
    output_type="summary",
    anonymize=False
)

# ✅ Create or update Langflow workflows
mcp_langflow_mcp_server_create_langflow(
    flow_config={
        "name": "Test Workflow",
        "data": {"nodes": [], "edges": []}
    }
)

# ✅ Living Truth Engine Flow
# Access: http://localhost:7860/flows/90d0cc9d-d590-4734-813e-5664c95f907a
# Test: "Investigate Entity A connections, output as network"
# Schema-based generation: Uses `config/langflow_schemas.json` from local Langflow code
# Direct MCP: Use `mcp_lf-cursor_*` tools for direct Langflow operations

# ✅ Langflow operations
mcp_langflow_mcp_server_list_langflow_tools()
```

### **Data Analysis Tools**
```python
# ✅ Transcript analysis
mcp_living_truth_fastmcp_server_analyze_transcript("transcript_name")

# ✅ Source management
mcp_living_truth_fastmcp_server_list_sources()

# ✅ Batch operations for efficiency
mcp_living_truth_fastmcp_server_batch_system_operations()
mcp_living_truth_fastmcp_server_batch_analysis_operations("query", "transcript_name")
```
mcp_living_truth_fastmcp_server_list_sources()

# ✅ Visualization generation
mcp_living_truth_fastmcp_server_generate_viz(viz_type="network")
```

## 🚨 **Common MCP Issues to Avoid**

### **Configuration Issues**
- ❌ **Using dashes in tool names** (use underscores)
- ❌ **Tool names over 60 characters** (causes filtering)
- ❌ **Incorrect server paths** or environment variables
- ❌ **Missing PYTHONPATH** configuration
- ❌ **Conflicting MCP configurations** across projects

### **Usage Issues**
- ❌ **Not checking server status** before using tools
- ❌ **Ignoring tool errors** without fallback
- ❌ **Using wrong tool** for the task
- ❌ **Not validating tool outputs**
- ❌ **Hardcoding tool calls** without error handling

### **Integration Issues**
- ❌ **Not using MCP tools** when available
- ❌ **Bypassing MCP** for operations it can handle
- ❌ **Inconsistent tool usage** patterns
- ❌ **Not documenting tool dependencies**
- ❌ **Ignoring MCP server health**

## 📊 **MCP Integration Metrics**

- ✅ **Tool Exposure**: 100% compliance with 15 meta-tools (under 40-tool limit)
- ✅ **Proxy Response Time**: <1s for execution (monitor with `measure_tool_performance`)
- ✅ **Registry Size**: Unlimited, tested up to 100 tools
- ✅ **Error Rate**: <5% in proxy calls (log via logger.error)
- ✅ **Server Uptime**: 99%+ MCP Hub Server availability
- ✅ **Tool Usage**: 90%+ operations use MCP when available
- ✅ **Documentation**: 100% of tools documented
- ✅ **Tool Count**: 63 tools correctly loaded and validated
- ✅ **Performance Monitoring**: Active with timing and warnings
- ✅ **Backup System**: Automatic registry backup and recovery

## 🎯 **MCP Development Workflow**

### **1. Development Setup**
```python
# ✅ Start MCP server
# Ensure living_truth_fastmcp_server.py is running

# ✅ Check server status
mcp_living_truth_fastmcp_server_get_status()

# ✅ Validate tool availability
mcp_living_truth_fastmcp_server_test_tool("MCP server ready")
```

### **2. Tool Usage Pattern**
```python
# ✅ Always check status first
try:
    status = mcp_living_truth_fastmcp_server_get_status()
    if status.get("status") == "healthy":
        # Use MCP tools
        result = mcp_living_truth_fastmcp_server_query_langflow("query")
    else:
        # Fall back to direct operations
        result = perform_direct_operation("query")
except Exception as e:
    # Handle MCP errors gracefully
    logger.error(f"MCP tool error: {e}")
    result = perform_fallback_operation("query")
```

### **3. Error Handling**
```python
# ✅ Comprehensive error handling
def safe_mcp_operation(operation_func, *args, **kwargs):
    """Safely execute MCP operation with fallback."""
    try:
        return operation_func(*args, **kwargs)
    except ConnectionError:
        logger.warning("MCP server unavailable, using fallback")
        return fallback_operation(*args, **kwargs)
    except ValueError as e:
        logger.error(f"Invalid MCP operation parameters: {e}")
        raise
    except Exception as e:
        logger.error(f"Unexpected MCP error: {e}")
        return fallback_operation(*args, **kwargs)
```

## 🔍 **MCP Server Monitoring**

### **Health Checks**
```python
# ✅ Regular status checks
def check_mcp_health():
    try:
        status = mcp_living_truth_fastmcp_server_get_status()
        return status.get("status") == "healthy"
    except Exception:
        return False

# ✅ Tool availability validation
def validate_tools():
    tools = [
        "get_status",
        "query_langflow", 
        "analyze_transcript",
        "list_sources"
    ]
    available_tools = []
    for tool in tools:
        try:
            # Test tool availability
            pass
        except Exception:
            logger.warning(f"Tool {tool} not available")
    return available_tools
```

### **Performance Monitoring**
```python
# ✅ Tool response times
import time

def measure_tool_performance(tool_func, *args, **kwargs):
    start_time = time.time()
    try:
        result = tool_func(*args, **kwargs)
        response_time = time.time() - start_time
        logger.info(f"Tool {tool_func.__name__} completed in {response_time:.2f}s")
        return result
    except Exception as e:
        logger.error(f"Tool {tool_func.__name__} failed after {time.time() - start_time:.2f}s: {e}")
        raise
```

## 🛠️ **MCP Troubleshooting**

### **Common Problems**
1. **Server not running**: Start `living_truth_fastmcp_server.py`
2. **Tool not found**: Check tool name spelling and availability
3. **Connection errors**: Verify server configuration and network
4. **Permission issues**: Check file permissions and user access
5. **Environment issues**: Verify PYTHONPATH and dependencies

### **Hub-Specific Issues**
- **Hub Registry Load Failure**: Check permissions (`ls -la config/tool_registry.json`); if invalid, validate with `validate_registry()`; reload with `reload_registry()`
- **Proxy Errors**: Ensure underlying server running (`mcp_hub_server_get_status()`); test import: `importlib.import_module(tool['module'])`
- **Tool Not Found**: Search registry first (`search_tools(tool_name)`); if missing, build with `build_tool()`
- **Performance Issues**: If >1s, check logs (`tail -f data/logs/hub.log`); optimize with batch tools
- **Registry Overflow**: If >100 tools, paginate `list_tools(page: int = 1, size: int = 20)`
- **Dynamic Build Failure**: If `build_tool()` fails (invalid code), log and return error details

### **Recovery Procedures**
```python
# ✅ Server restart procedure
def restart_mcp_server():
    try:
        # Stop current server
        stop_mcp_server()
        # Start new server
        start_mcp_server()
        # Validate restart
        status = mcp_living_truth_fastmcp_server_get_status()
        return status.get("status") == "healthy"
    except Exception as e:
        logger.error(f"Failed to restart MCP server: {e}")
        return False

# ✅ Tool recovery
def recover_tool_usage():
    if not check_mcp_health():
        restart_mcp_server()
    return check_mcp_health()
```

---

**Follow these MCP integration practices to ensure reliable, efficient, and maintainable tool usage.**

## 📚 **Related Rules**
- **@mcp_hub_server.mdc** - Detailed MCP Hub Server architecture and usage
- **@current_working_state.mdc** - Current system status and operational details
- **@project_overview.mdc** - Overall project architecture and components
- **@coding_standards.mdc** - Code quality and development standards
- **@development_workflow.mdc** - Development workflow and best practices
- **@docker_best_practices.mdc** - Docker configuration and deployment
- **@system_management.mdc** - System management and automation
